<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Scene</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #fff;
				font-family: Monospace;
				font-size: 13px;
				text-align: center;
				font-weight: bold;
				background-color: #000;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				position: absolute;
				width: 100%;
				text-align: center;
				padding: 5px;
			}
			a { color: black; }
		</style>
	</head>
	<body>
		<div id="info">
			<a href="#" target="_blank" rel="noopener">Chinese Painting</a>
		</div>
		<script src="/static/threejs/three.js"></script>
		<script src="/static/threejs/TrackballControls.js"></script>
		<script src="/static/threejs/Detector.js"></script>
		<script src="/static/threejs/stats.min.js"></script>
		<script src='/static/threejs/dat.gui.min.js'></script>
		<script src="/static/threejs/OBJLoader.js"></script>
		<script src="/static/threejs/ShaderTerrain.js"></script>
		<script src="/static/threejs/SkyShader.js"></script>
		<script src="/static/threejs/GPUComputationRenderer.js"></script>
		<script src="/static/threejs/SimplexNoise.js"></script>

		<script src="/static/threejs/Reflector.js"></script>
		<script src="/static/threejs/Refractor.js"></script>
		<script src="/static/threejs/Water2.js"></script>


		<script src="/static/cloud/CloudShader.js"></script>
        <script src="/static/cloud/Cloud.js"></script>

        <script id="waternoiseheightmapFragmentShader" type="x-shader/x-fragment">
			#include <common>
			uniform float viscosityConstant;
			#define deltaTime ( 1.0 / 60.0 )
			#define GRAVITY_CONSTANT ( resolution.x * deltaTime * 3.0 )
			void main()	{
				vec2 cellSize = 1.0 / resolution.xy;
				vec2 uv = gl_FragCoord.xy * cellSize;
				vec4 noiseheightmapValue = texture2D( noiseheightmap, uv );
				// Get neighbours
				vec4 north = texture2D( noiseheightmap, uv + vec2( 0.0, cellSize.y ) );
				vec4 south = texture2D( noiseheightmap, uv + vec2( 0.0, - cellSize.y ) );
				vec4 east = texture2D( noiseheightmap, uv + vec2( cellSize.x, 0.0 ) );
				vec4 west = texture2D( noiseheightmap, uv + vec2( - cellSize.x, 0.0 ) );
				float sump = north.x + south.x + east.x + west.x - 4.0 * noiseheightmapValue.x;
				float accel = sump * (GRAVITY_CONSTANT);
				// Dynamics
				noiseheightmapValue.y += accel;
				noiseheightmapValue.x += noiseheightmapValue.y * deltaTime;

				gl_FragColor = noiseheightmapValue;
			}
		</script>

		<script>
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
			//config
			SIZE_ELEMENT = 1;
			SIZE_GROUND_WIDTH = 100;
			SIZE_HOUSE_HEIGHT = SIZE_GROUND_WIDTH/20;
			SIZE_SUN_DISTANCE = SIZE_GROUND_WIDTH*100;
			SIZE_SHADOW_SCOPE = SIZE_SUN_DISTANCE*10;
			SIZE_MOUNTAIN_HEIGHT = SIZE_GROUND_WIDTH/5;
			SIZE_MOUNTAIN_HEIGHT_SCALE = SIZE_GROUND_WIDTH/50;
			SIZE_MOUNTAIN_HEIGHT_OFFSET = 1;
			SIZE_WATER_LEVEL = 0;
			WIDTH = 128;
			BOUNDS = SIZE_GROUND_WIDTH;
			//

			//variable
			var container, stats, manager;
			var camera, scene, renderer, clock;
			var waterHeightMap_gpuCompute, simplex;
			var mesh, geometry;
			var controls;
			var sky, water, sunSphere, sunLight, pointLight, ambientLight;
			var clouds = [];
			var heightmapVariable;
			var gui, shadowCameraHelper, shadowConfig = {
				shadowCameraVisible: false,
				shadowCameraNear: 488,
				shadowCameraFar: SIZE_SHADOW_SCOPE,
				shadowCameraFov: 15,
				shadowBias: 0.00332
			};
			var skyEffectController  = {
				turbidity: 20,
				rayleigh: 4,
				mieCoefficient: 0.1,
				mieDirectionalG: 0.5,
				luminance: 1,
				inclination: 0.4828, // elevation / inclination
				azimuth: 0.1723, // Facing front,
				sun: true
			};
			var fogConfig = {
				density: 0.01
			}
			//

			function initFlowWater(flowMap, speed, sizeX, sizeY) {
				var waterGeometry = new THREE.PlaneBufferGeometry( sizeX, sizeY, WIDTH - 1, WIDTH - 1 );
				var flowMap = new THREE.TextureLoader().load( flowMap );
				var normalMap0 = new THREE.TextureLoader().load( '/static/texture/Water_1_M_Normal.jpg' );
				var normalMap1 = new THREE.TextureLoader().load( '/static/texture/Water_2_M_Normal.jpg' );
				water = new THREE.Water( waterGeometry, {
					scale: 2,
					textureWidth: WIDTH,
					textureHeight: WIDTH,
					flowMap: flowMap,
					flowSpeed: speed,
					normalMap0: normalMap0,
					normalMap1: normalMap1,
					alpha: 0.6
				} );
				water.position.y = SIZE_WATER_LEVEL;
				water.rotation.x = Math.PI * - 0.5;
				scene.add( water );
				createGPUCompute(sizeX*0.04*speed);
			}

			function createGPUCompute(noiseMaxHeight) {
				waterHeightMap_gpuCompute = new GPUComputationRenderer( WIDTH, WIDTH, renderer );
				var waternoiseheightmap0 = waterHeightMap_gpuCompute.createTexture();
				fillWaterNoiseTexture(waternoiseheightmap0, noiseMaxHeight);
				fillWaterHeightTexture(waternoiseheightmap0);
				waternoiseheightmapVariable = waterHeightMap_gpuCompute.addVariable( "noiseheightmap", document.getElementById( 'waternoiseheightmapFragmentShader' ).textContent, waternoiseheightmap0 );


				waterHeightMap_gpuCompute.setVariableDependencies( waternoiseheightmapVariable, [ waternoiseheightmapVariable ] );

				waternoiseheightmapVariable.material.uniforms.time = { value: 0.0 };
				// Check for completeness
				var error = waterHeightMap_gpuCompute.init();
				if ( error !== null ) {
					console.error( error );
				}
			}

			function updateFlowWater() {
				if (waterHeightMap_gpuCompute!=undefined && water!=undefined) {
					waterHeightMap_gpuCompute.compute();
					water.material.uniforms.heightmap.value = waterHeightMap_gpuCompute.getCurrentRenderTarget( waternoiseheightmapVariable ).texture;
				}
			}

			function fillWaterTestTexture( texture ) { //randomly create texture on initHeighMap
				var pixels = texture.image.data;
				var p = 0;
				for ( var j = 0; j < WIDTH; j++ ) {
					for ( var i = 0; i < WIDTH; i++ ) {
						if (j<3) {
							var x = i * 128 / WIDTH;
							var y = j * 128 / WIDTH;
							pixels[ p + 0 ] += 2;
							pixels[ p + 1 ] = 0;
							pixels[ p + 2 ] = 0;
							pixels[ p + 3 ] = 1;
							p += 4;
						}
					}
				}
			}

			function fillWaterNoiseTexture( texture, noiseMaxHeight ) { //randomly create texture on initHeighMap
				function noise( x, y ) {
					var multR = noiseMaxHeight;
					var mult = 0.025;
					var r = 0;
					for ( var i = 0; i < 15; i++ ) {
						r += multR * simplex.noise( x * mult, y * mult );
						multR *= 0.53 + 0.025 * i;
						mult *= 1.25;
					}
					return r;
				}
				var pixels = texture.image.data;
				var p = 0;
				for ( var j = 0; j < WIDTH; j++ ) {
					for ( var i = 0; i < WIDTH; i++ ) {
						var x = i * 128 / WIDTH;
						var y = j * 128 / WIDTH;
						pixels[ p + 0 ] += noise( x, y );
						pixels[ p + 1 ] = 0;
						pixels[ p + 2 ] = 0;
						pixels[ p + 3 ] = 1;
						p += 4;
					}
				}
			}

			function fillWaterHeightTexture( texture ) { //randomly create texture on initHeighMap
				var pixels = texture.image.data;
				var p = 0;
				for ( var j = 0; j < WIDTH; j++ ) {
					for ( var i = 0; i < WIDTH; i++ ) {
						var x = i * 128 / WIDTH;
						var y = j * 128 / WIDTH;
						var tmp = 0 * Math.sqrt(Math.pow((x-0.5*WIDTH),2)+Math.pow((y-0.5*WIDTH),2));
						pixels[ p + 0 ] += tmp;
						pixels[ p + 1 ] = 0;
						pixels[ p + 2 ] = 0;
						pixels[ p + 3 ] = 1;
						p += 4;
					}
				}
			}

			function initCloud() {
				var wireframeMat = new THREE.MeshBasicMaterial({
					color : new THREE.Color(0x000000),
					wireframe : true
				});

				for(var i = 0; i < 1; i++) {
					var cloud = new THREE.Cloud();
					var wireframe = new THREE.Mesh(cloud.geometry.clone(), wireframeMat.clone());
					cloud.add(wireframe);
					wireframe.visible = false;
					cloud.position.set(-0.5*SIZE_GROUND_WIDTH+8*i+50,30,-0.5*SIZE_GROUND_WIDTH+20);
					cloud.rotation.set((Math.random()-0.5)*Math.PI, (Math.random()-0.5)*Math.PI, (Math.random()-0.5)*Math.PI);
					var scale = 50;
					cloud.scale.set(scale, scale, scale);
					scene.add(cloud);
					clouds.push(cloud);
				}
			}

			function initSky() {
				sky = new THREE.Sky();
				scene.add( sky.mesh );
				sunSphere = new THREE.Mesh(
					new THREE.SphereBufferGeometry( SIZE_GROUND_WIDTH/3, 16, 8 ),
					new THREE.MeshBasicMaterial( { color: 0xffffff } )
				);
				sunSphere.position.y = - 7*SIZE_GROUND_WIDTH;
				sunSphere.visible = false;
				scene.add( sunSphere );	

				ambientLight = new THREE.AmbientLight( 0x000000 );
				scene.add( ambientLight );
				sunLight = new THREE.SpotLight( 0xffffff, 0.5, 0, Math.PI/2 );
				sunLight.castShadow = true;
				sunLight.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( shadowConfig.shadowCameraFov, 1, shadowConfig.shadowCameraNear, shadowConfig.shadowCameraFar ) );
				sunLight.shadow.bias = shadowConfig.shadowBias;
				scene.add( sunLight );
				skyUpdated();			
			}

			function skyUpdated() {
				var distance = SIZE_SUN_DISTANCE;
				var uniforms = sky.uniforms;
				uniforms.turbidity.value = skyEffectController.turbidity;
				uniforms.rayleigh.value = skyEffectController.rayleigh;
				uniforms.luminance.value = skyEffectController.luminance;
				uniforms.mieCoefficient.value = skyEffectController.mieCoefficient;
				uniforms.mieDirectionalG.value = skyEffectController.mieDirectionalG;

				var theta = Math.PI * ( skyEffectController.inclination - 0.5 );
				var phi = 2 * Math.PI * ( skyEffectController.azimuth - 0.5 );

				sunSphere.position.x = distance * Math.cos( phi );
				sunSphere.position.y = 8*distance * Math.sin( phi ) * Math.sin( theta );
				sunSphere.position.z = distance * Math.sin( phi ) * Math.cos( theta );

				sunLight.position.x = distance/20 * Math.cos( phi );
				sunLight.position.y = distance * Math.sin( phi ) * Math.sin( theta );
				sunLight.position.z = distance/20 * Math.sin( phi ) * Math.cos( theta );
				sunLight.intensity = skyEffectController.luminance;
				ambientLight.intensity = 0.1+Math.abs(skyEffectController.azimuth-0.25);

				sunSphere.visible = skyEffectController.sun;
				sky.uniforms.sunPosition.value.copy( sunSphere.position );
			}

			function createGUI() {
				shadowCameraHelper = new THREE.CameraHelper( sunLight.shadow.camera );
				shadowCameraHelper.visible = shadowConfig.shadowCameraVisible;
				scene.add( shadowCameraHelper );

				// GUI
				gui = new dat.GUI( { width: 400 } );

				// SHADOW
				var shadowGUI = gui.addFolder( "Shadow" );
    			shadowGUI.add( shadowConfig, 'shadowCameraVisible' ).onChange( function() {
					shadowCameraHelper.visible = shadowConfig.shadowCameraVisible;
				});
				shadowGUI.add( shadowConfig, 'shadowCameraNear', 1, 1500 ).onChange( function() {
					sunLight.shadow.camera.near = shadowConfig.shadowCameraNear;
					sunLight.shadow.camera.updateProjectionMatrix();
					shadowCameraHelper.update();
				});
				shadowGUI.add( shadowConfig, 'shadowCameraFar', 1001, SIZE_SHADOW_SCOPE ).onChange( function() {
					sunLight.shadow.camera.far = shadowConfig.shadowCameraFar;
					sunLight.shadow.camera.updateProjectionMatrix();
					shadowCameraHelper.update();
				});
				shadowGUI.add( shadowConfig, 'shadowCameraFov', 1, 150 ).onChange( function() {
					sunLight.shadow.camera.fov = shadowConfig.shadowCameraFov;
					sunLight.shadow.camera.updateProjectionMatrix();
					shadowCameraHelper.update();
				});
				shadowGUI.add( shadowConfig, 'shadowBias', -0.01, 0.1 ).onChange( function() {
					sunLight.shadow.bias = shadowConfig.shadowBias;
				});
				shadowGUI.open();

				//SKY
				var skyGUI = gui.addFolder( "Sky" );
    			skyGUI.add( skyEffectController, "turbidity", 1.0, 20.0, 0.1 ).onChange( skyUpdated );
				skyGUI.add( skyEffectController, "rayleigh", 0.0, 4, 0.001 ).onChange( skyUpdated );
				skyGUI.add( skyEffectController, "mieCoefficient", 0.0, 0.1, 0.001 ).onChange( skyUpdated );
				skyGUI.add( skyEffectController, "mieDirectionalG", 0.0, 1, 0.001 ).onChange( skyUpdated );
				skyGUI.add( skyEffectController, "luminance", 0.0, 1 ).onChange( skyUpdated );
				skyGUI.add( skyEffectController, "inclination", 0, 0.3, 0.0001 ).onChange( skyUpdated );
				skyGUI.add( skyEffectController, "azimuth", 0, 0.5, 0.0001 ).onChange( skyUpdated );
				skyGUI.add( skyEffectController, "sun" ).onChange( skyUpdated );
				skyGUI.open();

				//FOG
				var skyGUI = gui.addFolder( "Fog" );
    			skyGUI.add( fogConfig, "density", 0, 0.02, 0.001 ).onChange( function() {
					scene.fog.density = fogConfig.density; 
				});
				skyGUI.open();
			}


			function loadObjectMaterial(texturePath) {
				var textureLoader = new THREE.TextureLoader();
				var textureColor = textureLoader.load( texturePath );
				textureColor.repeat.set( 1, 1 );
				textureColor.wrapS = textureColor.wrapT = THREE.RepeatWrapping;
				textureColor.format = THREE.RGBFormat;
				return textureColor;
			}

			function createObject(objGroundPos, objVerticalPos, objPath, texturePath, objectTypeStandardSize) {
				var onProgress = function ( xhr ) {
					if ( xhr.lengthComputable ) {
						var percentComplete = xhr.loaded / xhr.total * 100;
						console.log( Math.round(percentComplete, 2) + '% downloaded' );
					}
				};
				var onError = function ( xhr ) {
				};
				var loader = new THREE.OBJLoader( manager );
				loader.load( objPath, function ( object ) {
					if (texturePath!=null){
						object.traverse( function ( child ) {
							if ( child instanceof THREE.Mesh ) {
								var tmpB = new THREE.Box3().setFromObject(child);
								var tmpBH = tmpB.max.y-tmpB.min.y;
								if (tmpBH>0.8*objectTypeStandardSize) {
									child.castShadow = true;
								}
								if (tmpBH>0.1*objectTypeStandardSize) {
									child.material.map = loadObjectMaterial(texturePath);
								}
							}
						} );
					}
					var bbox = new THREE.Box3().setFromObject(object);
					var tmpH = bbox.max.y - bbox.min.y; 
					var scale = objectTypeStandardSize/tmpH;
					object.position.set( objGroundPos[0], objVerticalPos, objGroundPos[1] );
					object.scale.set(scale,scale,scale);
					scene.add( object );
				}, onProgress, onError );
			}

			function getImageData( image ) {
			    var canvas = document.createElement( 'canvas' );
			    canvas.width = image.width;
			    canvas.height = image.height;
			    var context = canvas.getContext( '2d' );
			    context.drawImage( image, 0, 0 );
			    return context.getImageData( 0, 0, image.width, image.height );
			}

			function buildTerrain(tex, texturePath) {
			    var material = new THREE.MeshLambertMaterial({
			        map: THREE.ImageUtils.loadTexture(texturePath)
			    });
			    var geometry = new THREE.PlaneGeometry(tex.image.width, tex.image.height, tex.image.width-1, tex.image.height-1);
			    var pixelList = getImageData( tex.image ).data;
			    for (var i = 0, l = geometry.vertices.length; i < l; i++) {
			        geometry.vertices[i].z = (pixelList[i*4]+pixelList[i*4+1]+pixelList[i*4+2])/3;
			    }
			    geometry.computeFaceNormals();
			    geometry.computeVertexNormals();
			    geometry.computeTangents();
			    console.warn(geometry.faces);
			    return new THREE.Mesh(geometry, material);
			}

			function initTerrain(heightmapPath, texturePath, mountainSize, groundSize) {
				var tex = THREE.ImageUtils.loadTexture(heightmapPath, THREE.UVMapping, function() {
					var terrain = buildTerrain( tex, texturePath );
					terrain.position.set( 0, -SIZE_MOUNTAIN_HEIGHT_OFFSET, 0 );
					terrain.rotation.x = - Math.PI / 2;
					terrain.scale.set( groundSize/tex.image.width, groundSize/tex.image.width, SIZE_MOUNTAIN_HEIGHT_SCALE*mountainSize/255);
					initFlowWater('/static/texture/Water_1_M_Flow.jpg', 0.1, groundSize, groundSize*tex.image.height/tex.image.width);
					terrain.receiveShadow = true;
					terrain.castShadow = true;
					scene.add( terrain );
				} );
			}

			function initFog() {
				//scene.fog = new THREE.Fog( 0, 1000, 10000 );
				scene.fog = new THREE.FogExp2( 0xffffff, fogConfig.density );
			}

			function initSceneAndCamera() {
				clock = new THREE.Clock();
				simplex = new SimplexNoise();
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000000 );
				camera.position.set( SIZE_GROUND_WIDTH/2, SIZE_GROUND_WIDTH/6, SIZE_GROUND_WIDTH );
				scene = new THREE.Scene();
				controls = new THREE.TrackballControls( camera, renderer.domElement );
				controls.rotateSpeed = 15.0;
				controls.zoomSpeed = 6;
				controls.panSpeed = 0.8;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.15;
				controls.keys = [ 65, 83, 68 ];
				// STATS
				stats = new Stats();
				container.appendChild( stats.dom );
			}

			function createView() {
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				renderer.gammaInput = true;
				renderer.gammaOutput = true;
				renderer.setPixelRatio( window.devicePixelRatio );
				window.addEventListener( 'resize', onWindowResize, false );
			}

			function placeObjects() {
				//createObject([-100, -50], 450, "/static/obj/1.obj", "/static/texture/1.png", SIZE_HOUSE_HEIGHT/4);
			}

			function onWindowResize( event ) {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
				controls.handleResize();
			}
			function animate() {
				requestAnimationFrame( animate );
				stats.begin();
				render();
				stats.end();
			}
			function render() {
				var t = clock.elapsedTime * 1.0;
				/*for(var i = 0, n = clouds.length; i < n; i++) {
					var cloud = clouds[i];
					cloud.update(t);
				}*/
				updateFlowWater();
				controls.update();
				renderer.render( scene, camera );
			}

			createView();
			initSceneAndCamera();
			//initCloud();
			initFog();
			initSky();
			initTerrain("/static/terrain/heightMap.png", "/static/terrain/texture.png", SIZE_MOUNTAIN_HEIGHT, SIZE_GROUND_WIDTH);

			createGUI();
			//placeObjects();
			animate();
		</script>
	</body>
</html>
